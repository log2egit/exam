#include <stdlib.h>
#include <stdio.h>
                                                        //каждое число вводить с новой строки. После каждого числа (особенно после последнего) ставить перевод на новую строку (Enter).
                                                        //После последнего числа (с новой строки) послать EOF (у меня Ctrl+C).
typedef struct ARR_STRUCT {                             //объявляем новый тип (структуру)
    int *a;                                             //здесь будет указатель на наш динамический массив
    int len;                                            //зсдесь будет его длинна (колличество элементов)
} ARR;                                                  //наш новый тип будет называться ARR

ARR *scan() {                                           //создаём функцию считывания, она будет возвращать указетель на наш тип (струтуру) ARR
    ARR *cur_arr = (ARR *)malloc(sizeof(ARR));          //выделяем динамическую память для струтуры ARR, присваеваем указатель на нее переменной cur_arr. Так будет называться экземпляр струтуры внутри нашей функции.
    if (cur_arr == NULL) return(NULL);                  //если память не выделилась, возвратим NULL 
    int max_len = 1;                                    //начальная длинна. Потом в этой переменной будем хранить текущую длинну динамического массива (память на сколько элементов выделена)
    cur_arr->a = (int *)malloc(max_len * sizeof(int));  //создаём динамический массив, присваеваем его первому элементу струтуры a. Полный путь к массиву получается cur_arr->a
    if (cur_arr->a == NULL) return(NULL);               //если память не выделилась, возвратим NULL     
    cur_arr->len = 0;                                   //Второй элемент струтуры будет счетчиком по массиву. Одновременно показывает первое свободное место и колличество элементов массива (сколько реально считано элементов).
    int c;                                              //сюда будем считывать текущее введенное число
    while(scanf("%i", &c) != EOF) {                     //считываем введенное число в переменную c, пока scanf не вернула EOF (конец ввода)
        if (cur_arr->len+1 > max_len) {                 //проверяем, что номер нового элемента не превосходит размер нашего массива (i+1 так как индексация с 0)
            cur_arr->a = (int *)realloc(cur_arr->a, (max_len*=2)*sizeof(int));//если превосходит, расширяем массив в 2 раза (и увеличваем max_len).
            if (cur_arr->a == NULL) return(NULL);       //если память не выделилась, возвратим NULL
        }
        cur_arr->a[cur_arr->len] = c;                   //вставляем на первое свободное место наш новый элемент
        cur_arr->len++;                                 //увеличиваем счетчик колличества элементов
    }
    return cur_arr;                                     //возвращаем указатель на нашу структуру
}

int main() {
    ARR *arr_1 = scan();                                //создаём указатель на тип ARR, присваевам ему возвращаемое значение функции scan().
    if (arr_1 == NULL) return(1);                       //если были проблемы в функции, завершаем с ошибкой
//    for(int n = 0; n<arr_1->len; n++) printf("%i ", arr_1->a[n]);//выводим наш массив.
                                                        //После ввода к массиву можно применьть любой алгоритм сортировки. arr_1->a хранит указатель на массив. arr_1->len хранит его длинну (кол-во элементов).
    return 0;
}
